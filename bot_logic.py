# bot_logic.py
# ---------------------------------------------------------------------------
#  ‚úîÔ∏è  –¢–µ–∫—Å—Ç –∏–ª–∏ –≥–æ–ª–æ—Å  ‚Üí STT (Vosk) ‚Üí get_response (NLP-–ª–æ–≥–∏–∫–∞) ‚Üí TTS-WAV
#     ‚Üí –∫–æ–Ω–≤–µ—Ä—Å–∏—è –≤ OGG/Opus  ‚Üí voice-—Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Telegram.
# ---------------------------------------------------------------------------

import os, json, random, re, pyttsx3
from datetime import datetime
from pathlib   import Path
from collections import deque

from dotenv import load_dotenv
from telegram import Update
from telegram.ext import (
    Updater, CommandHandler, MessageHandler, Filters, CallbackContext,
)
from pydub import AudioSegment

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–æ–¥—É–ª–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
from modules.tictactoe import TicTacToe
from nlp_utils          import clean_text, lemmatize_text, correct_spelling
from intent_classifier   import IntentClassifier
from sentiment           import get_sentiment
from recommendations     import recommend
from dialogue_retrieval  import DialogueRetriever
from audio_utils         import stt_from_wav                 # –æ—Ñ–ª–∞–π–Ω-Vosk

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –æ–∫—Ä—É–∂–µ–Ω–∏–µ / –∫–∞—Ç–∞–ª–æ–≥–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
load_dotenv()
BASE_DIR = Path(__file__).parent
DATA_DIR = BASE_DIR / "data"
TEMP_DIR = BASE_DIR / "temp"; TEMP_DIR.mkdir(exist_ok=True)

INTENTS_F = DATA_DIR / "intents_dataset.json"
CUSTOM_F  = DATA_DIR / "custom_intents.json"
CATALOG_F = DATA_DIR / "product_catalog.json"
DIALOG_F  = DATA_DIR / "dialogues.txt"

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –¥–∞–Ω–Ω—ã–µ –∏ ML-–º–æ–¥–µ–ª–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
INTENTS = json.loads(INTENTS_F.read_text('utf-8'))
if CUSTOM_F.exists():
    INTENTS.update(json.loads(CUSTOM_F.read_text('utf-8')))
PRODUCT_CATALOG = json.loads(CATALOG_F.read_text('utf-8'))

clf       = IntentClassifier(DATA_DIR);  clf.load()
retriever = DialogueRetriever(str(DIALOG_F))

DICTIONARY = {ex.lower() for d in INTENTS.values() if isinstance(d, dict)
                             for ex in d.get("examples", [])}
if DIALOG_F.exists():
    for ln in DIALOG_F.read_text('utf-8').splitlines():
        DICTIONARY.update(re.findall(r"[–∞-—è—ëa-z]+", ln.lower()))

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TTS (pyttsx3 ‚Üí WAV) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tts = pyttsx3.init()
for v in tts.getProperty("voices"):
    if "russian" in v.name.lower() and "male" in v.name.lower():
        tts.setProperty("voice", v.id); break
tts.setProperty("rate", 140)

def _tts_to_wav(text: str, path: Path):
    tts.save_to_file(text, str(path))
    tts.runAndWait()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ —É—Ç–∏–ª–∏—Ç—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _parse_iso(ts):
    try: return datetime.fromisoformat(ts) if isinstance(ts, str) else ts
    except: return None

def _save_custom_intents(data: dict):
    CUSTOM_F.write_text(json.dumps(data, ensure_ascii=False, indent=4), 'utf-8')

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–µ–∫–ª–∞–º—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
AD_COOLDOWN_MSG, AD_COOLDOWN_HOURS = 3, 1
SEASONAL_EVENTS = {"11-11":"–ß—ë—Ä–Ω–∞—è –ø—è—Ç–Ω–∏—Ü–∞","03-08":"8 –º–∞—Ä—Ç–∞","23-02":"23 —Ñ–µ–≤—Ä–∞–ª—è"}
AD_TRIGGERS = {
    ("—Å–æ–Ω","—É—Å—Ç–∞–ª","—Å–ø–∞–ª"): ("–ú–∞—Ç—Ä–∞—Å—ã",None,"–ö—Å—Ç–∞—Ç–∏, —Ö–æ—Ä–æ—à–∏–π –º–∞—Ç—Ä–∞—Å —Ç–≤–æ—Ä–∏—Ç —á—É–¥–µ—Å–∞ —Å–æ —Å–Ω–æ–º. –•–æ—á–µ—à—å –≤–∑–≥–ª—è–Ω—É—Ç—å?"),
    ("—Å–ø–∏–Ω–∞","–±–æ–ª–∏—Ç","–ø–æ—è—Å–Ω–∏—Ü–∞"): ("–ú–∞—Ç—Ä–∞—Å—ã",None,"–ü–æ–º–æ–∂–µ—Ç –æ—Ä—Ç–æ–ø–µ–¥–∏—á–µ—Å–∫–∏–π –º–∞—Ç—Ä–∞—Å —Å –∑–æ–Ω–∞–ª—å–Ω–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π üòâ"),
    ("–ø–µ—Ä–µ–µ–∑–¥","—Ä–µ–º–æ–Ω—Ç","–∫–≤–∞—Ä—Ç–∏—Ä"): ("–ö—Ä–æ–≤–∞—Ç–∏",None,"–ù–æ–≤–æ—Å–µ–ª—å–µ ‚Äî –æ—Ç–ª–∏—á–Ω—ã–π –ø–æ–≤–æ–¥ –æ–±–Ω–æ–≤–∏—Ç—å –∫—Ä–æ–≤–∞—Ç—å. –ü–æ–¥–∫–∏–Ω—É—Ç—å –∏–¥–µ–∏?"),
}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ì–õ–ê–í–ù–ê–Ø –ª–æ–≥–∏–∫–∞ –æ—Ç–≤–µ—Ç–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def get_response(text: str, user_data: dict, history: deque) -> str:
    prefs      = user_data.setdefault("preferences", {})
    custom_ans = user_data.setdefault("custom_answers", {})
    last_int   = user_data.get("last_intent")
    last_bot   = user_data.get("last_bot")

    low        = text.lower().strip()
    low_clean  = re.sub(r"[^–∞-—è—ëa-z0-9\s]", "", low)

    # —Å—á—ë—Ç—á–∏–∫–∏ / —Ç–∏–ø—ã --------------------------------------------------------
    user_data["asked_questions"] = set(user_data.get("asked_questions", []))
    user_data["shown_products"]  = set(user_data.get("shown_products",  []))
    user_data.setdefault("asked_followup", False)
    user_data.setdefault("msgs_since_ad",   0)
    user_data["last_ad_ts"] = _parse_iso(user_data.get("last_ad_ts"))

    user_data["msgs_since_ad"] += 1
    now = datetime.utcnow()
    hours_since = ((now - user_data["last_ad_ts"]).total_seconds()/3600) if user_data["last_ad_ts"] else 1e9

    def _can_offer(): return user_data["msgs_since_ad"]>=AD_COOLDOWN_MSG and hours_since>=AD_COOLDOWN_HOURS
    def _offer(r): user_data.update(last_ad_ts=now.isoformat(), msgs_since_ad=0); return r

    # 0. hello/bye —á–µ—Ä–µ–∑ ML-–∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä
    try:
        i0 = clf.predict_intent(text)
        if i0 in INTENTS and i0 in {"hello","bye"}:
            r = random.choice(INTENTS[i0]["responses"])
            user_data.update(last_intent=i0,last_bot=r)
            return r
    except: pass

    # 1. small-talk
    if re.search(r"\b–∫–∞–∫\s+(–¥–µ–ª[–∞–∏]|—Ç—ã)\b", low_clean):
        return random.choice(["–£ –º–µ–Ω—è –≤—Å—ë –æ—Ç–ª–∏—á–Ω–æ, —Å–ø–∞—Å–∏–±–æ! –ê —É —Ç–µ–±—è?","–í—Å—ë —Ö–æ—Ä–æ—à–æ, —Ä–∞–±–æ—Ç–∞—é –Ω–µ –ø–æ–∫–ª–∞–¥–∞—è —Ç—Ä–∞–Ω–∑–∏—Å—Ç–æ—Ä–æ–≤ üòÑ –ê —Ç—ã?"])
    if "–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏" in low_clean:
        return random.choice(["–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å—É–ø–µ—Ä! –ö–∞–∫ —Ç–≤–æ—ë?","–ë–æ–¥—Ä–æ–µ –∏ –≤–µ—Å—ë–ª–æ–µ. –£ —Ç–µ–±—è –∫–∞–∫–æ–µ?"])

    # 2. –æ–∂–∏–¥–∞–µ–º—ã–π –∂–∞–Ω—Ä
    if user_data.get("awaiting_genre"):
        cat   = user_data.pop("awaiting_genre")
        reply = recommend(cat, low_clean)
        prefs[f"{cat}_genre"] = low_clean
        user_data.update(last_intent=cat,last_bot=reply)
        return reply

    # 3. —Å–µ–∑–æ–Ω–Ω—ã–µ –æ—Ñ—Ñ–µ—Ä—ã
    if now.strftime("%m-%d") in SEASONAL_EVENTS and _can_offer():
        return _offer(f"–î–æ {SEASONAL_EVENTS[now.strftime('%m-%d')]} —Å–∫–∏–¥–∫–∞ ‚Äì25 % –Ω–∞ –º–∞—Ç—Ä–∞—Å—ã. –ü–æ–∫–∞–∑–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã?")

    # 4. —Ç—Ä–∏–≥–≥–µ—Ä–Ω—ã–µ –æ—Ñ—Ñ–µ—Ä—ã
    for keys,(cat,sub,pitch) in AD_TRIGGERS.items():
        if any(k in low_clean for k in keys) and _can_offer():
            user_data.update(expect_more=True,last_ad_category=cat,last_ad_subcategory=sub,ad_offer_shown=True)
            if sub:
                prod=random.choice(PRODUCT_CATALOG[cat][sub])
                return _offer(pitch+f"\n\n*{prod['name']}*\n{prod['description']}\n–¶–µ–Ω–∞: {prod['price']} ‚ÇΩ\n–ü–æ–¥—Ä–æ–±–Ω–µ–µ: {prod['link']}")
            user_data["awaiting_ad_choice"]=True
            return _offer(pitch)

    # 5. —Å–±—Ä–æ—Å —Ä–µ–∂–∏–º–∞ ¬´–µ—â—ë¬ª
    if user_data.get("expect_more") and low not in {"–µ—â–µ","–µ—â—ë","–µ—â–µ —Ä–∞–∑","–µ—â—ë —Ä–∞–∑"}:
        user_data["expect_more"]=False; user_data["shown_products"].clear()

    # 6. –ø—Ä—è–º–æ–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    for cat in PRODUCT_CATALOG:
        if re.search(rf"\b{cat.lower()}\b", low_clean):
            user_data.pop("awaiting_ad_choice",None)
            user_data.update(shop_cat=cat, ad_offer_shown=True)
            return f"–û—Ç–ª–∏—á–Ω–æ! –ö–∞–∫–∏–µ –∏–º–µ–Ω–Ω–æ {cat.lower()} –∏–Ω—Ç–µ—Ä–µ—Å—É—é—Ç: {', '.join(PRODUCT_CATALOG[cat])}?"

    # 7. —è–≤–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –∫–∞—Ç–∞–ª–æ–≥–∞
    def _catalog_offer():
        user_data["awaiting_ad_choice"]=True
        return "–í –∫–∞—Ç–∞–ª–æ–≥–µ –µ—Å—Ç—å –æ—Ç–ª–∏—á–Ω—ã–µ **–∫—Ä–æ–≤–∞—Ç–∏** –∏ **–º–∞—Ç—Ä–∞—Å—ã**. –ß—Ç–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–µ–µ?"
    if any(cmd in low for cmd in ("/catalog","–∫–∞—Ç–∞–ª–æ–≥","—Ç–æ–≤–∞—Ä—ã")) and _can_offer():
        user_data["ad_offer_shown"]=True
        return _offer(_catalog_offer())

    # 8. –∞–≤—Ç–æ-–æ—Ñ—Ñ–µ—Ä
    if len(history)>=3 and not user_data.get("ad_offer_shown") and not user_data.get("awaiting_ad_choice") and _can_offer():
        user_data["ad_offer_shown"]=True
        return _offer(_catalog_offer())

    # 9. –≤—ã–±–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if user_data.get("awaiting_ad_choice"):
        if low_clean in {"–Ω–µ—Ç","–Ω–µ","–Ω–µ–∞","no"}:
            user_data.pop("awaiting_ad_choice"); user_data["ad_offer_shown"]=True
            return "–•–æ—Ä–æ—à–æ! –°–∫–∞–∂–∏, –∫–æ–≥–¥–∞ –∑–∞—Ö–æ—á–µ—à—å –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞—Ç–∞–ª–æ–≥ üôÇ"
        for cat in PRODUCT_CATALOG:
            if low_clean==cat.lower():
                user_data.update(shop_cat=cat); user_data.pop("awaiting_ad_choice")
                return f"–ö–∞–∫–∏–µ –∏–º–µ–Ω–Ω–æ {cat.lower()} –∏–Ω—Ç–µ—Ä–µ—Å—É—é—Ç: {', '.join(PRODUCT_CATALOG[cat])}?"
        user_data.pop("awaiting_ad_choice")

    # 10. –ø–µ—Ä–≤–∞—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è
    if "shop_cat" in user_data and "shop_sub" not in user_data:
        cat=user_data["shop_cat"]
        for sub in PRODUCT_CATALOG[cat]:
            if low_clean in {sub.lower(),*sub.lower().split()}:
                user_data.update(last_ad_category=cat,last_ad_subcategory=sub,expect_more=True)
                prod=random.choice(PRODUCT_CATALOG[cat][sub])
                user_data["shown_products"].add(prod["name"])
                user_data.pop("shop_cat")
                return f"–†–µ–∫–æ–º–µ–Ω–¥—É—é: *{prod['name']}*\n\n{prod['description']}\n\n–¶–µ–Ω–∞: {prod['price']} ‚ÇΩ\n–ü–æ–¥—Ä–æ–±–Ω–µ–µ: {prod['link']}"

    # 11. ¬´–µ—â—ë¬ª
    if user_data.get("expect_more") and low in {"–µ—â–µ","–µ—â—ë","–µ—â–µ —Ä–∞–∑","–µ—â—ë —Ä–∞–∑"}:
        cat,sub=user_data["last_ad_category"], user_data["last_ad_subcategory"]
        rest=[p for p in PRODUCT_CATALOG[cat][sub] if p["name"] not in user_data["shown_products"]]
        if not rest:
            user_data["expect_more"]=False; user_data["shown_products"].clear()
            return "–ü–æ–∂–∞–ª—É–π, —ç—Ç–æ –≤—Å–µ –ª—É—á—à–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã üòâ"
        prod=random.choice(rest); user_data["shown_products"].add(prod["name"])
        return f"–ï—â—ë –≤–∞—Ä–∏–∞–Ω—Ç: *{prod['name']}*\n\n{prod['description']}\n\n–¶–µ–Ω–∞: {prod['price']} ‚ÇΩ\n–ü–æ–¥—Ä–æ–±–Ω–µ–µ: {prod['link']}"

    # 12. –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ
    if waiting:=user_data.get("awaiting_teach"):
        custom_ans[waiting]=text; user_data.pop("awaiting_teach")
        return random.choice(["–°–ø–∞—Å–∏–±–æ, –∑–∞–ø–æ–º–Ω–∏–ª!","–û—Ç–ª–∏—á–Ω–æ, –ø—Ä–∏–Ω—è–ª –∫ —Å–≤–µ–¥–µ–Ω–∏—é!"])
    if text in custom_ans:
        return custom_ans[text]

    # 13. ¬´–õ—é–±–∏–º–æ–µ X¬ª
    if "awaiting_pref_topic" in user_data:
        prefs[user_data.pop("awaiting_pref_topic")]=text
        return f"–°–ø–∞—Å–∏–±–æ! –ó–∞–ø–æ–º–Ω–∏–ª, —á—Ç–æ —Ç–µ–±–µ –Ω—Ä–∞–≤–∏—Ç—Å—è {text}."
    if (m:=re.search(r"–ª—é–±–∏–º(?:–æ–µ|–∞—è|—ã–π|—ã–µ)\s+([\w\-–∞-—è—ë]+)", low_clean)):
        k=f"favorite_{m.group(1)}"
        if k in prefs: return f"–ú–Ω–µ –Ω—Ä–∞–≤–∏—Ç—Å—è {prefs[k]}."
        user_data["awaiting_pref_topic"]=k
        return f"–ê —á—Ç–æ —Ç–µ–±–µ –±–æ–ª—å—à–µ –≤—Å–µ–≥–æ –Ω—Ä–∞–≤–∏—Ç—Å—è –≤ –ø–ª–∞–Ω–µ {m.group(1)}?"

    # 14. encore (¬´–µ—â—ë¬ª)
    if low in {"–µ—â–µ","–µ—â—ë","–µ—â–µ —Ä–∞–∑","–µ—â—ë —Ä–∞–∑"}:
        if last_int in {"joke","anecdote","fun_fact","fact"}:
            pool=[r for r in INTENTS[last_int]["responses"] if r!=last_bot]
            return random.choice(pool) if pool else random.choice(INTENTS[last_int]["responses"])
        if last_int in {"music","movie","game","series"}:
            return recommend(last_int, prefs.get(f"{last_int}_genre"))

    # 15. –∫—Ä–µ—Å—Ç–∏–∫–∏-–Ω–æ–ª–∏–∫–∏
    if "–∫—Ä–µ—Å—Ç–∏–∫–∏" in low:
        user_data["tic_tac_toe"]=TicTacToe()
        return "–ù–∞—á–∏–Ω–∞–µ–º ¬´–∫—Ä–µ—Å—Ç–∏–∫–∏-–Ω–æ–ª–∏–∫–∏¬ª!\n"+user_data['tic_tac_toe'].render()+"\n–¢–≤–æ–π —Ö–æ–¥ (A1..C3):"

    # 16. –∂–∞–Ω—Ä –ø–æ—Å–ª–µ follow-up
    for cat in {"music","movie","game","series"}:
        if last_int==cat and f"{cat}_genre" not in prefs:
            rec=recommend(cat, text.strip()); prefs[f"{cat}_genre"]=text.strip()
            user_data["last_bot"]=rec
            return rec

    # 17. sentiment + intent-predict
    lemma = lemmatize_text(
        " ".join(correct_spelling(w, DICTIONARY) for w in clean_text(text).split())
    )
    tone = "–ú–Ω–µ –∂–∞–ª—å, —á—Ç–æ —Ç–µ–±–µ –≥—Ä—É—Å—Ç–Ω–æ. " if get_sentiment(lemma)<-0.2 else \
           "–†–∞–¥ –∑–∞ —Ç–µ–±—è! "                if get_sentiment(lemma)>0.5  else ""

    intent=None
    for p in (lambda x: clf.predict(x), lambda x: clf.predict_fuzzy(x)):
        try:
            c=p(lemma)
            if c in INTENTS: intent=c; break
        except: pass

    if intent in {"music","movie","game","series"}:
        user_data.update(last_intent=intent, asked_followup=True, awaiting_genre=intent)
        return INTENTS[intent]["follow_up"][0]

    if intent:
        opts=INTENTS[intent]["responses"]
        if last_bot in opts and len(opts)>1: opts=[o for o in opts if o!=last_bot]
        resp=random.choice(opts)
        user_data["last_bot"]=resp
        if not user_data["asked_followup"]:
            for f in INTENTS[intent].get("follow_up", []):
                if f not in user_data["asked_questions"]:
                    resp+=" "+f
                    user_data["asked_questions"].add(f)
                    user_data["asked_followup"]=True
                    break
        user_data["last_intent"]=intent
        return tone+resp

    # 18. retrieval-–æ—Ç–≤–µ—Ç
    cand=retriever.get_answer(lemma)
    if cand:
        user_data.update(last_bot=cand,last_intent=None)
        return tone+cand

    # 19. fallback ‚Üí –æ–±—É—á–µ–Ω–∏–µ
    cid=f'c{re.sub(r"[^a-z0-9]","",low_clean) or "intent"}'
    new_i={"examples":[text],"responses":["–Ø –ø–æ–∫–∞ –Ω–µ –∑–Ω–∞—é, –∫–∞–∫ –Ω–∞ —ç—Ç–æ –æ—Ç–≤–µ—Ç–∏—Ç—å. –ü–æ–¥—Å–∫–∞–∂–∏—Ç–µ –ø—Ä–∏–º–µ—Ä –æ—Ç–≤–µ—Ç–∞?"]}
    extra=json.loads(CUSTOM_F.read_text('utf-8')) if CUSTOM_F.exists() else {}
    extra[cid]=new_i; _save_custom_intents(extra); INTENTS[cid]=new_i
    user_data["awaiting_teach"]=text
    return "–Ø –ø–æ–∫–∞ –Ω–µ –∑–Ω–∞—é, –∫–∞–∫ –Ω–∞ —ç—Ç–æ –æ—Ç–≤–µ—á–∞—Ç—å. –ü–æ–¥—Å–∫–∞–∂–∏—Ç–µ –ø—Ä–∏–º–µ—Ä –æ—Ç–≤–µ—Ç–∞?"

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helper: –æ—Ç–ø—Ä–∞–≤–∏—Ç—å voice-—Å–æ–æ–±—â–µ–Ω–∏–µ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _reply_voice(update: Update, reply_text: str, stub: str):
    wav = TEMP_DIR / f"{stub}.wav"
    ogg = TEMP_DIR / f"{stub}.ogg"
    _tts_to_wav(reply_text, wav)
    AudioSegment.from_wav(wav).export(ogg, format="ogg", codec="libopus", bitrate="48k")
    with open(ogg, "rb") as f:
        update.message.reply_voice(voice=f, caption=reply_text)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Telegram-handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def handle_voice(update: Update, context: CallbackContext):
    au = update.message.voice or update.message.audio or update.message.document
    if not au:
        return update.message.reply_text("–ù–µ —Å–º–æ–≥ –ø–æ–ª—É—á–∏—Ç—å –∞—É–¥–∏–æ.")
    fid = getattr(au, "file_unique_id", None) or update.message.message_id
    src = TEMP_DIR / f"{fid}.src"
    wav_in = TEMP_DIR / f"{fid}.in.wav"
    au.get_file().download(str(src))
    # –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –∫–æ–Ω–≤–µ—Ä—Å–∏—è: 48k/opus ‚Üí 16k 16-bit mono, +6 dB
    audio = AudioSegment.from_file(src)
    audio = (audio.set_frame_rate(16000)
                   .set_channels(1)
                   .set_sample_width(2)   # 16-bit
                   .apply_gain(+6))       # —á—É—Ç–æ—á–∫—É –≥—Ä–æ–º—á–µ
    audio.export(wav_in, format="wav")

    try:
        user_text = stt_from_wav(str(wav_in))
    except Exception as e:
        return update.message.reply_text(f"–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: {e}")

    # ‚¨áÔ∏è –ù–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
    if not user_text.strip():
        return update.message.reply_text(
            "–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ —Ä–∞—Å—Å–ª—ã—à–∞–ª ‚Äì –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –ø—Ä–æ–∏–∑–Ω–µ—Å—Ç–∏ —á—É—Ç—å –æ—Ç—á—ë—Ç–ª–∏–≤–µ–µ."
        )

    update.message.reply_text(f"üó£ –í—ã —Å–∫–∞–∑–∞–ª–∏: {user_text}")

    ud=context.user_data; hist=ud.setdefault("history",deque(maxlen=50))
    bot_text=get_response(user_text, ud, hist); hist.extend((user_text, bot_text))
    _reply_voice(update, bot_text, f"{fid}_resp")

def handle_text(update: Update, context: CallbackContext):
    user_text = update.message.text
    update.message.reply_text(f"üó£ –í—ã —Å–∫–∞–∑–∞–ª–∏: {user_text}")
    ud=context.user_data; hist=ud.setdefault("history",deque(maxlen=50))
    bot_text=get_response(user_text, ud, hist); hist.extend((user_text, bot_text))
    _reply_voice(update, bot_text, f"{update.message.message_id}_resp")

def start(update: Update,_): update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –ü—Ä–∏—à–ª–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –≥–æ–ª–æ—Å ‚Äî –æ—Ç–≤–µ—á—É –≥–æ–ª–æ—Å–æ–º üôÇ")
def help_command(update: Update,_): update.message.reply_text("–Ø —Ä–∞—Å–ø–æ–∑–Ω–∞—é —Ä–µ—á—å (Vosk) –∏ –æ—Ç–≤–µ—á–∞—é voice-—Å–æ–æ–±—â–µ–Ω–∏–µ–º.")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ main() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ-
def main():
    token=os.getenv("TELEGRAM_TOKEN")
    if not token:
        raise RuntimeError("TELEGRAM_TOKEN –Ω–µ –∑–∞–¥–∞–Ω.")
    up=Updater(token)
    dp=up.dispatcher
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("help",  help_command))
    dp.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_text))
    dp.add_handler(MessageHandler(Filters.voice | Filters.audio | Filters.document, handle_voice))
    up.start_polling(); up.idle()

if __name__=="__main__":
    main()
